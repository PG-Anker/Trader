Got it ğŸ‘ â€” fetching 100+ symbols Ã— 200 candles is a lot of data, and with your current setup (rateLimit 3000 + artificial sleeps + sequential requests), itâ€™s guaranteed to crawl.

Letâ€™s break it down:

ğŸ”¢ What youâ€™re asking the exchange for

100 symbols Ã— 200 candles = 20,000 candles total.

Each REST call returns 200 candles for 1 symbol.

So you need 100 requests.

With rateLimit: 3000 (3s/request sequentially) â†’ 300 seconds (5 minutes).

With Bybitâ€™s real limit (~20 requests/sec) â†’ ~5 seconds if parallelized.

âœ… Fix strategy

Lower the CCXT rateLimit

new ccxt.bybit({
  enableRateLimit: true,
  rateLimit: 200,   // 5 requests per second per client is safe
})


You can even push rateLimit: 100 (~10 req/s) without issues if only using one bot.

Batch in parallel
Instead of waiting 500ms per symbol, fetch each batch of symbols using Promise.all.
Example: fetch 10 symbols in parallel, then pause 200â€“300ms, then next 10.

async batchFetchOHLCV(symbols: string[], timeframe: string, limit: number, forSpot = true): Promise<Record<string, OHLCV[]>> {
  const results: Record<string, OHLCV[]> = {};
  const batchSize = 10;  // 10 parallel requests
  const batchDelay = 300; // ms pause between batches

  for (let i = 0; i < symbols.length; i += batchSize) {
    const batch = symbols.slice(i, i + batchSize);

    const batchResults = await Promise.all(batch.map(async (symbol) => {
      try {
        const ohlcv = await this.getOHLCV(symbol, timeframe, limit, forSpot);
        return [symbol, ohlcv];
      } catch (err) {
        console.error(`âŒ Failed to fetch ${symbol}:`, err);
        return [symbol, []];
      }
    }));

    for (const [symbol, data] of batchResults) {
      results[symbol as string] = data as OHLCV[];
    }

    if (i + batchSize < symbols.length) {
      await new Promise(res => setTimeout(res, batchDelay));
    }
  }

  return results;
}


This way:

100 symbols / 10 per batch = 10 batches.

Each batch takes ~200â€“500ms (parallel).

Total time ~3â€“5 seconds instead of minutes.

WebSockets for live trading
REST = snapshot data (slow, repetitive).
WebSocket = streaming (cheap, real-time, efficient).

Bybit supports OHLCV subscription (kline).

Youâ€™d just subscribe once for 100+ symbols, and the server pushes every update.

ğŸš€ Expected improvement

Current: 100 symbols Ã— 3s/request â‰ˆ 5 minutes.

After batching: 100 symbols in 10 batches â‰ˆ 3â€“5 seconds.

With WebSockets: near instant updates without refetching.